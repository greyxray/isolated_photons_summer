#include <TH1D.h>
Double_t polcorr0405e(Double_t x)
{
   const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 0.998582, 0.992687, 0.989461, 0.987409,
                        0.98602, 0.984832, 0.983755, 0.983217, 0.9829,
                        0.982188, 0.982021, 0.981745, 0.981305, 0.980827,
                        0.980981, 0.980749, 0.980774, 0.980683, 0.980683 };
   const double fB[20] = { -3.46251e-07, -4.35475e-06, -4.593e-06, -2.04916e-06, -1.55241e-06,
                        -1.09398e-06, -1.07348e-06, -7.63619e-07, -2.58908e-07, -5.2434e-07,
                        -4.39044e-07, -1.09112e-07, -3.28974e-07, -5.17868e-07, -9.21101e-08,
                        5.82964e-09, -1.4449e-07, 1.08479e-08, -7.7063e-08, 1.01823e-07 };
   const double fC[20] = { -4.8012e-09, -2.454e-09, 2.23829e-09, 6.59196e-11, 3.84032e-10,
                        3.12121e-11, -1.26437e-11, 2.93187e-10, 1.63772e-10, -4.042e-10,
                        4.81462e-10, -1.82611e-10, -1.65398e-11, -1.54482e-10, 5.39958e-10,
                        -4.51244e-10, 3.15085e-10, -1.74381e-10, 9.47515e-11, 552 };
   const double fD[20] = { 1.41611e-12, 1.41611e-12, -6.55908e-13, 9.60484e-14, -1.06528e-13,
                        -1.32415e-14, 9.22984e-14, -3.90568e-14, -1.71489e-13, 2.6741e-13,
                        -2.00505e-13, 5.01421e-14, -4.16304e-14, 2.09579e-13, -2.99276e-13,
                        2.3138e-13, -1.47786e-13, 8.12598e-14, 8.12598e-14, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}

Double_t polcorr0405eLH(Double_t x)
{
  const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 0.994448, 0.971591, 0.959091, 0.950835,
                        0.945453, 0.940836, 0.93795, 0.934837, 0.934496,
                        0.934804, 0.928249, 0.928949, 0.930882, 0.926255,
                        0.927486, 0.926843, 0.927063, 0.926127, 0.926127 };
   const double fB[20] = { -1.47353e-06, -1.69494e-05, -1.77406e-05, -8.13478e-06, -6.12158e-06,
                        -4.43751e-06, -3.30031e-06, -2.74793e-06, -2.00385e-06, 1.3822e-06,
                        -3.61436e-06, -3.89869e-06, 3.29984e-06, -2.14805e-06, -2.0261e-06,
                        1.0309e-06, -4.97853e-07, -1.89326e-07, -6.8986e-07, 8.93608e-07 };
   const double fC[20] = { -1.85557e-08, -9.45487e-09, 8.73854e-09, -3.76432e-11, 1.86119e-09,
                        -3.35771e-10, 1.36584e-09, -8.65723e-10, 1.5394e-09, 1.52768e-09,
                        -6.05355e-09, 5.796e-09, 7.24403e-10, -5.65684e-09, 5.76725e-09,
                        -2.99822e-09, 1.61348e-09, -1.33402e-09, 8.80637e-10, 552 };
   const double fD[20] = { 5.49069e-12, 5.49069e-12, -2.64981e-12, 5.7332e-13, -6.63334e-13,
                        5.13772e-13, -6.73477e-13, 7.25856e-13, -3.53893e-15, -2.28902e-12,
                        3.57776e-12, -1.53128e-12, -1.92583e-12, 3.44774e-12, -2.64658e-12,
                        1.39242e-12, -8.89946e-13, 6.68676e-13, 6.68676e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}

Double_t polcorr0405eRH(Double_t x)
{
  const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00707, 1.03596, 1.05265, 1.06388,
                        1.07444, 1.07954, 1.08437, 1.08775, 1.09115,
                        1.09358, 1.09599, 1.09748, 1.09908, 1.09994,
                        1.10147, 1.10287, 1.10358, 1.10617, 1.10617 };
   const double fB[20] = { 2.28022e-06, 2.12833e-05, 2.29773e-05, 1.06231e-05, 1.03938e-05,
                        7.02901e-06, 4.02984e-06, 3.82759e-06, 2.98264e-06, 2.66876e-06,
                        2.18249e-06, 1.75498e-06, 1.38537e-06, 1.08845e-06, 9.49845e-07,
                        1.5996e-06, 6.06008e-07, 1.71382e-06, 1.51717e-06, -1.88417e-06 };
   const double fC[20] = { 2.26758e-08, 1.17189e-08, -1.01851e-08, -1.00527e-09, 7.97571e-10,
                        -3.84542e-09, 1.12878e-09, -1.31189e-09, 5.46876e-10, -8.3118e-10,
                        3.90713e-10, -7.77947e-10, 4.43151e-10, -7.11975e-10, 5.86484e-10,
                        2.06058e-12, -9.02052e-10, 1.90551e-09, -2.08364e-09, 552 };
   const double fD[20] = { -6.61053e-12, -6.61053e-12, 2.77169e-12, 5.44336e-13, -1.40187e-12,
                        1.50187e-12, -7.36584e-13, 5.60968e-13, -4.1608e-13, 3.68929e-13,
                        -3.52856e-13, 3.68689e-13, -3.48612e-13, 3.9187e-13, -1.76456e-13,
                        -2.72981e-13, 8.47693e-13, -1.20445e-12, -1.20445e-12, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}


Double_t polcorr06e(Double_t x)
{
  const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00178, 1.01043, 1.01506, 1.01819,
                        1.01989, 1.02217, 1.02355, 1.02451, 1.02557,
                        1.02625, 1.02685, 1.0269, 1.02745, 1.02764,
                        1.02801, 1.02854, 1.02879, 1.03041, 1.03041 };
   const double fB[20] = { -3.99014e-07, 6.15716e-06, 6.71155e-06, 3.07247e-06, 2.07789e-06,
                        1.72707e-06, 1.82927e-06, 8.99015e-07, 9.50363e-07, 7.86048e-07,
                        6.15676e-07, 2.25632e-07, 2.55496e-07, 3.97933e-07, 1.474e-07,
                        5.40561e-07, 1.43924e-07, 9.8951e-07, 9.70889e-07, -1.21245e-06 };
   const double fC[20] = { 7.82783e-09, 4.03854e-09, -3.53661e-09, 2.4034e-10, -1.14122e-09,
                        8.23448e-10, -7.30868e-10, -1.11377e-10, 1.57867e-10, -3.06703e-10,
                        1.5238e-10, -5.05682e-10, 5.32733e-10, -4.03772e-10, 1.76942e-10,
                        1.79182e-10, -5.38454e-10, 1.30438e-09, -1.32125e-09, 552 };
   const double fD[20] = { -2.28615e-12, -2.28615e-12, 1.14038e-12, -4.17139e-13, 5.93198e-13,
                        -4.69298e-13, 1.8696e-13, 8.12565e-14, -1.40269e-13, 1.38612e-13,
                        -1.9869e-13, 3.13531e-13, -2.82633e-13, 1.75257e-13, 6.76306e-16,
                        -2.16678e-13, 5.56412e-13, -7.92764e-13, -7.92764e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}

Double_t polcorr06eLH(Double_t x)
{
  const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 0.994537, 0.972751, 0.960998, 0.953038,
                        0.947996, 0.943546, 0.940793, 0.937654, 0.937547,
                        0.937864, 0.931421, 0.932182, 0.934215, 0.92946,
                        0.930818, 0.930124, 0.930449, 0.92946, 0.92946 };
   const double fB[20] = { -1.84306e-06, -1.63446e-05, -1.67554e-05, -7.74085e-06, -5.84876e-06,
                        -4.19637e-06, -3.15904e-06, -2.73602e-06, -1.8991e-06, 1.51393e-06,
                        -3.58658e-06, -3.81311e-06, 3.39803e-06, -2.19079e-06, -2.0274e-06,
                        1.07898e-06, -4.84726e-07, -1.42872e-07, -7.48777e-07, 9.7384e-07 };
   const double fC[20] = { -1.74374e-08, -8.80971e-09, 8.43778e-09, -2.72448e-10, 1.98629e-09,
                        -4.89566e-10, 1.42917e-09, -1.04617e-09, 1.8039e-09, 1.2876e-09,
                        -5.90763e-09, 5.70243e-09, 8.294e-10, -5.88945e-09, 6.03738e-09,
                        -3.22363e-09, 1.80723e-09, -1.49758e-09, 9.48756e-10, 552 };
   const double fD[20] = { 5.20522e-12, 5.20522e-12, -2.6299e-12, 6.81988e-13, -7.47542e-13,
                        5.79329e-13, -7.47047e-13, 8.60139e-13, -1.55888e-13, -2.17247e-12,
                        3.50545e-12, -1.47133e-12, -2.02772e-12, 3.59946e-12, -2.7962e-12,
                        1.51898e-12, -9.97831e-13, 7.38629e-13, 7.38629e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}

Double_t polcorr06eRH(Double_t x)
{
  const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00611, 1.03034, 1.04457, 1.05405,
                        1.06106, 1.06895, 1.06952, 1.07363, 1.08018,
                        1.08193, 1.07734, 1.08117, 1.08592, 1.08248,
                        1.08569, 1.08681, 1.08801, 1.08786, 1.08786 };
   const double fB[20] = { 2.46103e-06, 1.80052e-05, 1.92256e-05, 9.56472e-06, 6.94542e-06,
                        7.47005e-06, 3.68213e-06, 7.97511e-07, 5.81883e-06, 4.88645e-06,
                        -2.80531e-06, -1.3852e-06, 6.29369e-06, -4.89085e-07, -7.7285e-07,
                        2.95856e-06, 6.82044e-07, 6.27957e-07, -3.31855e-07, 4.74806e-07 };
   const double fC[20] = { 1.85733e-08, 9.56086e-09, -8.45593e-09, -2.94833e-10, -2.07772e-09,
                        2.55294e-09, -5.98403e-09, 3.37234e-09, 1.1739e-09, -2.01845e-09,
                        -4.94872e-09, 6.23505e-09, 7.20461e-10, -6.86149e-09, 6.60458e-09,
                        -3.22468e-09, 1.16262e-09, -1.21161e-09, 3.42215e-10, 552 };
   const double fD[20] = { -5.43739e-12, -5.43739e-12, 2.4641e-12, -5.38313e-13, 1.39815e-12,
                        -2.57759e-12, 2.82371e-12, -6.63481e-13, -9.63872e-13, -8.84745e-13,
                        3.37674e-12, -1.66503e-12, -2.2882e-12, 4.064e-12, -2.96777e-12,
                        1.32467e-12, -7.16856e-13, 4.6915e-13, 4.6915e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}


Double_t polcorr0607p(Double_t x)
{
     const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00085, 1.00649, 1.00973, 1.01221,
                        1.01394, 1.0151, 1.0161, 1.01724, 1.01774,
                        1.01561, 1.0189, 1.01954, 1.01959, 1.02006,
                        1.01997, 1.02054, 1.02091, 1.02103, 1.02103 };
   const double fB[20] = { -1.12591e-06, 3.70913e-06, 4.54247e-06, 2.25198e-06, 1.98728e-06,
                        1.23361e-06, 9.29679e-07, 9.05271e-07, 1.28192e-06, -1.56242e-06,
                        5.20889e-07, 2.61249e-06, -2.79328e-07, 3.87871e-07, 1.21433e-07,
                        1.61015e-07, 5.49975e-07, 1.83723e-07, 3.51901e-08, -3.47043e-08 };
   const double fC[20] = { 5.70878e-09, 3.04241e-09, -2.28792e-09, 2.13201e-10, -4.52962e-10,
                        -2.29713e-10, -4.55876e-11, 2.34894e-11, 3.1752e-10, -2.89391e-09,
                        4.78096e-09, -2.8864e-09, 2.66999e-10, 3.37074e-10, -5.78304e-10,
                        6.14157e-10, -2.61839e-10, -6.99107e-11, -6.46303e-11, 552 };
   const double fD[20] = { -1.60867e-12, -1.60867e-12, 7.55169e-13, -2.01136e-13, 6.7406e-14,
                        5.55934e-14, 2.08471e-14, 8.8737e-14, -9.69634e-13, 2.31729e-12,
                        -2.31502e-12, 9.52112e-13, 2.11484e-14, -2.76257e-13, 3.60043e-13,
                        -2.64491e-13, 5.79493e-14, 1.59433e-15, 1.59433e-15, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));

}

Double_t polcorr0607pLH(Double_t x)
{
   const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00767, 1.04083, 1.06066, 1.07534,
                        1.08756, 1.09581, 1.10323, 1.10862, 1.1136,
                        1.11452, 1.12088, 1.12478, 1.12685, 1.12989,
                        1.13206, 1.13392, 1.13601, 1.1381, 1.1381 };
   const double fB[20] = { 1.41212e-06, 2.40011e-05, 2.65705e-05, 1.36509e-05, 1.26101e-05,
                        9.01111e-06, 6.97232e-06, 5.67138e-06, 5.13429e-06, 1.96652e-06,
                        3.02556e-06, 5.70135e-06, 2.0531e-06, 2.32095e-06, 2.53573e-06,
                        1.67475e-06, 1.72694e-06, 2.17013e-06, 9.60038e-07, -1.12442e-06 };
   const double fC[20] = { 2.6871e-08, 1.40141e-08, -1.16878e-08, -1.47197e-11, -9.28074e-10,
                        -2.33184e-09, 4.85115e-10, -1.66297e-09, 1.1767e-09, -4.04605e-09,
                        5.00532e-09, -2.5816e-09, -7.22972e-10, 9.65485e-10, -7.71032e-10,
                        -8.8377e-12, 5.61137e-11, 3.45318e-10, -1.44141e-09, 552 };
   const double fD[20] = { -7.75675e-12, -7.75675e-12, 3.5245e-12, -2.75771e-13, -4.23843e-13,
                        8.50531e-13, -6.48283e-13, 8.57e-13, -1.57692e-12, 2.7329e-12,
                        -2.29074e-12, 5.6118e-13, 5.09569e-13, -5.24073e-13, 2.30131e-13,
                        1.96109e-14, 8.73202e-14, -5.39471e-13, -5.39471e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}

Double_t polcorr0607pRH(Double_t x)
{
   const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 0.993539, 0.968652, 0.954997, 0.945681,
                        0.938022, 0.933292, 0.929157, 0.924515, 0.925285,
                        0.922015, 0.918155, 0.917294, 0.913353, 0.912812,
                        0.912662, 0.909314, 0.911115, 0.91172, 0.91172 };
   const double fB[20] = { -2.83656e-06, -1.88038e-05, -1.92731e-05, -8.80245e-06, -7.93833e-06,
                        -5.57193e-06, -3.43913e-06, -4.75636e-06, -1.37488e-06, -2.57525e-07,
                        -4.38912e-06, -1.56063e-06, -2.1976e-06, -2.69038e-06, 7.87311e-07,
                        -2.33764e-06, -9.4346e-07, 1.90768e-06, -1.48299e-07, 3.13872e-07 };
   const double fC[20] = { -1.91973e-08, -9.70272e-09, 9.27782e-09, 2.06468e-10, 5.76252e-10,
                        1.56722e-09, 3.64666e-10, -1.55727e-09, 4.61882e-09, -3.60673e-09,
                        -1.3566e-10, 2.6977e-09, -3.27467e-09, 2.82851e-09, 3.20148e-10,
                        -3.15072e-09, 4.41356e-09, -1.831e-09, -3.12948e-11, 552 };
   const double fD[20] = { 5.72825e-12, 5.72825e-12, -2.73894e-12, 1.1165e-13, 2.99206e-13,
                        -3.63091e-13, -5.80033e-13, 1.86392e-12, -2.48356e-12, 1.04803e-12,
                        8.55483e-13, -1.80325e-12, 1.84191e-12, -7.57013e-13, -1.04797e-12,
                        2.2839e-12, -1.88544e-12, 5.43391e-13, 5.43391e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}



