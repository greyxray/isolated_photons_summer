#include <TH1D.h>
Double_t polcorr0607p_pos(Double_t x)
{
  const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00142, 1.0073, 1.01092, 1.01367,
                        1.01566, 1.01693, 1.01793, 1.01911, 1.02019,
                        1.01769, 1.02121, 1.02201, 1.02195, 1.02247,
                        1.0225, 1.02306, 1.02343, 1.02365, 1.02365 };
   const double fB[20] = { 4.43973e-07, 4.29546e-06, 4.7267e-06, 2.59171e-06, 2.2189e-06,
                        1.41637e-06, 9.87563e-07, 8.07696e-07, 1.69723e-06, -1.46945e-06,
                        3.33549e-07, 2.93108e-06, -3.16774e-07, 3.32194e-07, 2.3748e-07,
                        2.09691e-07, 5.22507e-07, 2.46847e-07, 9.25122e-08, -1.05994e-07 };
   const double fC[20] = { 4.5826e-09, 2.38841e-09, -1.99797e-09, 6.41064e-11, -4.01795e-10,
                        -3.25134e-10, -6.32785e-11, -9.95705e-11, 9.04944e-10, -3.77331e-09,
                        5.40646e-09, -3.05363e-09, 1.11736e-10, 4.75831e-10, -5.61584e-10,
                        5.36413e-10, -2.53066e-10, 3.37408e-12, -1.4317e-10, 552 };
   const double fD[20] = { -1.32379e-12, -1.32379e-12, 6.22609e-13, -1.40671e-13, 2.31463e-14,
                        7.90627e-14, -1.09528e-14, 3.03158e-13, -1.41252e-12, 2.77167e-12,
                        -2.55438e-12, 9.55726e-13, 1.09882e-13, -3.13088e-13, 3.31521e-13,
                        -2.38369e-13, 7.74274e-14, -4.42465e-14, -4.42465e-14, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));

}
Double_t polcorr0607p_neg(Double_t x)
{
 const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00091, 1.00673, 1.01008, 1.01263,
                        1.01439, 1.01563, 1.01667, 1.01792, 1.01857,
                        1.01619, 1.01957, 1.02015, 1.0203, 1.02078,
                        1.02071, 1.02129, 1.02167, 1.02179, 1.02179 };
   const double fB[20] = { -1.05317e-06, 3.85459e-06, 4.67515e-06, 2.33966e-06, 2.02242e-06,
                        1.28117e-06, 9.9689e-07, 9.36168e-07, 1.46693e-06, -1.64555e-06,
                        4.30887e-07, 2.64934e-06, -2.88642e-07, 4.72464e-07, 1.15657e-07,
                        1.79339e-07, 5.59309e-07, 1.92188e-07, 3.71368e-08, -3.67303e-08 };
   const double fC[20] = { 5.79848e-09, 3.08436e-09, -2.34144e-09, 2.25961e-10, -5.13319e-10,
                        -1.58104e-10, -9.93919e-11, 4.44152e-11, 4.36131e-10, -3.2554e-09,
                        5.13623e-09, -3.12676e-09, 4.65547e-10, 2.23548e-10, -5.46597e-10,
                        6.0428e-10, -2.60105e-10, -7.2432e-11, -6.80133e-11, 552 };
   const double fD[20] = { -1.63748e-12, -1.63748e-12, 7.75181e-13, -2.23213e-13, 1.07251e-13,
                        1.77272e-14, 4.34004e-14, 1.18218e-13, -1.11459e-12, 2.53371e-12,
                        -2.49487e-12, 1.08463e-12, -7.3034e-14, -2.32427e-13, 3.47487e-13,
                        -2.60986e-13, 5.66645e-14, 1.33416e-15, 1.33416e-15, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));

}
Double_t polcorr0405e_pos(Double_t x)
{
  const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 0.99852, 0.992401, 0.989058, 0.986686,
                        0.985467, 0.984245, 0.983123, 0.982553, 0.982233,
                        0.981491, 0.98131, 0.98102, 0.980568, 0.980089,
                        0.980234, 0.979993, 0.980012, 0.979917, 0.979917 };
   const double fB[20] = { -3.59412e-07, -4.54343e-06, -4.71566e-06, -2.29735e-06, -1.62429e-06,
                        -9.64e-07, -1.15271e-06, -7.93388e-07, -2.71329e-07, -5.37524e-07,
                        -4.63297e-07, -1.18361e-07, -3.43616e-07, -5.2231e-07, -9.54388e-08,
                        -3.8715e-09, -1.51168e-07, 5.75056e-09, -7.83557e-08, 1.03201e-07 };
   const double fC[20] = { -5.02298e-09, -2.54991e-09, 2.39399e-09, -2.03494e-10, 8.13153e-10,
                        -2.15065e-10, 4.41317e-11, 2.81194e-10, 1.91472e-10, -4.32591e-10,
                        4.99826e-10, -1.87385e-10, -1.665e-11, -1.45137e-10, 5.31621e-10,
                        -4.48679e-10, 3.15258e-10, -1.73122e-10, 9.69386e-11, 552 };
   const double fD[20] = { 1.49205e-12, 1.49205e-12, -7.84263e-13, 3.06959e-13, -3.10452e-13,
                        7.82597e-14, 7.15443e-14, -2.70777e-14, -1.88425e-13, 2.81527e-13,
                        -2.07491e-13, 5.15503e-14, -3.87769e-14, 2.04243e-13, -2.95984e-13,
                        2.30658e-13, -1.47458e-13, 8.154e-14, 8.154e-14, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));

}
Double_t polcorr0405e_neg(Double_t x)
{
  const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 0.998637, 0.992961, 0.989858, 0.987868,
                        0.986505, 0.985406, 0.984322, 0.983843, 0.983552,
                        0.982857, 0.982703, 0.982391, 0.982014, 0.98154,
                        0.981703, 0.981476, 0.981508, 0.981419, 0.981419 };
   const double fB[20] = { -3.25128e-07, -4.19118e-06, -4.4209e-06, -1.97318e-06, -1.5267e-06,
                        -1.03143e-06, -1.03726e-06, -7.50591e-07, -2.06556e-07, -5.14139e-07,
                        -4.15041e-07, -1.34061e-07, -3.15351e-07, -4.74798e-07, -9.6241e-08,
                        1.56081e-08, -1.40475e-07, 1.57144e-08, -7.68437e-08, 1.01839e-07 };
   const double fC[20] = { -4.63059e-09, -2.36678e-09, 2.15879e-09, 5.83423e-11, 3.46078e-10,
                        1.02539e-10, -1.07826e-10, 3.67377e-10, 1.25185e-10, -4.03793e-10,
                        4.93556e-10, -2.39045e-10, 7.48325e-11, -2.19193e-10, 5.61934e-10,
                        -4.60621e-10, 3.19242e-10, -1.77766e-10, 9.39273e-11, 552 };
   const double fD[20] = { 1.3658e-12, 1.3658e-12, -6.34195e-13, 8.68766e-14, -7.35323e-14,
                        -6.3516e-14, 1.43414e-13, -7.30925e-14, -1.59716e-13, 2.70939e-13,
                        -2.21196e-13, 9.47696e-14, -8.87357e-14, 2.35741e-13, -3.08742e-13,
                        2.35466e-13, -1.50063e-13, 8.2033e-14, 8.2033e-14, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));

}
Double_t polcorr06e_pos(Double_t x)
{
   const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.0018, 1.01054, 1.01521, 1.01837,
                        1.0201, 1.0224, 1.02379, 1.02477, 1.02583,
                        1.02642, 1.02712, 1.02718, 1.02774, 1.02793,
                        1.02831, 1.02883, 1.02909, 1.0307, 1.0307 };
   const double fB[20] = { -3.94362e-07, 6.22135e-06, 6.77508e-06, 3.10257e-06, 2.10804e-06,
                        1.74684e-06, 1.84602e-06, 9.03243e-07, 9.77633e-07, 7.20335e-07,
                        6.20598e-07, 3.04377e-07, 2.42856e-07, 4.09057e-07, 1.49286e-07,
                        5.40438e-07, 1.44835e-07, 9.91628e-07, 9.70217e-07, -1.21143e-06 };
   const double fC[20] = { 7.89978e-09, 4.07436e-09, -3.57302e-09, 2.4646e-10, -1.1473e-09,
                        8.20128e-10, -7.30287e-10, -1.23293e-10, 1.90645e-10, -4.23705e-10,
                        3.33364e-10, -6.19796e-10, 5.64071e-10, -4.13595e-10, 1.78401e-10,
                        1.75903e-10, -5.34238e-10, 1.30126e-09, -1.32065e-09, 552 };
   const double fD[20] = { -2.30795e-12, -2.30795e-12, 1.15322e-12, -4.20822e-13, 5.94031e-13,
                        -4.6812e-13, 1.83188e-13, 9.47451e-14, -1.85492e-13, 2.28583e-13,
                        -2.8779e-13, 3.57448e-13, -2.95056e-13, 1.78662e-13, -7.54404e-16,
                        -2.14415e-13, 5.54196e-13, -7.91641e-13, -7.91641e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));

}
Double_t polcorr06e_neg(Double_t x)
{
   const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00171, 1.00974, 1.01406, 1.01696,
                        1.01851, 1.02067, 1.022, 1.02286, 1.02384,
                        1.02454, 1.02503, 1.02505, 1.02557, 1.02574,
                        1.02615, 1.0266, 1.02683, 1.02843, 1.02843 };
   const double fB[20] = { -1.99513e-07, 5.76624e-06, 6.22346e-06, 2.87328e-06, 1.90521e-06,
                        1.60129e-06, 1.76103e-06, 8.37254e-07, 8.45915e-07, 7.87106e-07,
                        5.77313e-07, 1.40185e-07, 2.37833e-07, 3.64095e-07, 1.7019e-07,
                        5.1995e-07, 9.12404e-08, 9.83804e-07, 9.61027e-07, -1.19986e-06 };
   const double fC[20] = { 7.13002e-09, 3.66772e-09, -3.25376e-09, 2.19173e-10, -1.09605e-09,
                        8.20754e-10, -6.76057e-10, -1.60321e-10, 1.68163e-10, -2.21432e-10,
                        3.14025e-11, -4.27352e-10, 5.15801e-10, -4.01485e-10, 2.25927e-10,
                        9.08849e-11, -4.79209e-10, 1.28769e-09, -1.30832e-09, 552 };
   const double fD[20] = { -2.08887e-12, -2.08887e-12, 1.04859e-12, -3.97107e-13, 5.78744e-13,
                        -4.51935e-13, 1.55647e-13, 9.9135e-14, -1.17631e-13, 7.63389e-14,
                        -1.38513e-13, 2.84768e-13, -2.76833e-13, 1.8935e-13, -4.07735e-14,
                        -1.7213e-13, 5.33484e-13, -7.8382e-13, -7.8382e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}


//23.9.9 - new pol corrections for GR data
Double_t polcorr0405e(Double_t x)
{
  const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 0.998582, 0.99268, 0.989454, 0.987398,
                        0.986006, 0.984819, 0.983742, 0.983197, 0.982886,
                        0.982173, 0.982007, 0.98173, 0.981291, 0.980814,
                        0.980972, 0.980734, 0.980759, 0.980667, 0.980667 };
   const double fB[20] = { -3.41124e-07, -4.35882e-06, -4.59655e-06, -2.05011e-06, -1.55629e-06,
                        -1.09509e-06, -1.07185e-06, -7.68402e-07, -2.58808e-07, -5.21422e-07,
                        -4.3971e-07, -1.08001e-07, -3.30178e-07, -5.17673e-07, -8.77874e-08,
                        4.5457e-09, -1.48649e-07, 1.14939e-08, -7.78572e-08, 1.02906e-07 };
   const double fC[20] = { -4.81238e-09, -2.45947e-09, 2.24423e-09, 6.23282e-11, 3.84969e-10,
                        3.27866e-11, -1.17345e-11, 2.86471e-10, 1.74909e-10, -4.12783e-10,
                        4.86798e-10, -1.86336e-10, -1.49107e-11, -1.54845e-10, 5.44057e-10,
                        -4.60422e-10, 3.21659e-10, -1.76601e-10, 9.56675e-11, 552 };
   const double fD[20] = { 1.41956e-12, 1.41956e-12, -6.58787e-13, 9.74156e-14, -1.06335e-13,
                        -1.34424e-14, 8.99972e-14, -3.36691e-14, -1.77443e-13, 2.71613e-13,
                        -2.03241e-13, 5.17589e-14, -4.22315e-14, 2.10926e-13, -3.03285e-13,
                        2.36136e-13, -1.50441e-13, 8.22068e-14, 8.22068e-14, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}

Double_t polcorr0405eLH(Double_t x)
{
 const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 0.994448, 0.971587, 0.959084, 0.95083,
                        0.945446, 0.940828, 0.937944, 0.934828, 0.934487,
                        0.934797, 0.92824, 0.928939, 0.930874, 0.926243,
                        0.927478, 0.926834, 0.927053, 0.926119, 0.926119 };
   const double fB[20] = { -1.47113e-06, -1.69514e-05, -1.77446e-05, -8.13476e-06, -6.12165e-06,
                        -4.43947e-06, -3.29876e-06, -2.74833e-06, -2.00608e-06, 1.38412e-06,
                        -3.61484e-06, -3.90081e-06, 3.30134e-06, -2.14989e-06, -2.02543e-06,
                        1.03284e-06, -4.99615e-07, -1.8867e-07, -6.89576e-07, 8.93277e-07 };
   const double fC[20] = { -1.85607e-08, -9.45784e-09, 8.73969e-09, -3.51436e-11, 1.85861e-09,
                        -3.34895e-10, 1.36815e-09, -8.69804e-10, 1.54183e-09, 1.52901e-09,
                        -6.05705e-09, 5.79802e-09, 7.25673e-10, -5.66115e-09, 5.77384e-09,
                        -3.00367e-09, 1.61558e-09, -1.33393e-09, 8.8021e-10, 552 };
   const double fD[20] = { 5.49194e-12, 5.49194e-12, -2.64941e-12, 5.71786e-13, -6.6229e-13,
                        5.14205e-13, -6.75405e-13, 7.27821e-13, -3.87225e-15, -2.29048e-12,
                        3.57943e-12, -1.53151e-12, -1.92752e-12, 3.45103e-12, -2.65021e-12,
                        1.3947e-12, -8.90553e-13, 6.6852e-13, 6.6852e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}

Double_t polcorr0405eRH(Double_t x)
{
   const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00707, 1.03596, 1.05265, 1.06388,
                        1.07444, 1.07954, 1.08437, 1.08775, 1.09115,
                        1.09358, 1.09599, 1.09748, 1.09908, 1.09994,
                        1.10146, 1.10287, 1.10358, 1.10617, 1.10617 };
   const double fB[20] = { 2.28293e-06, 2.12812e-05, 2.29777e-05, 1.06236e-05, 1.03934e-05,
                        7.03041e-06, 4.02949e-06, 3.82757e-06, 2.98307e-06, 2.66704e-06,
                        2.18245e-06, 1.75688e-06, 1.38434e-06, 1.09067e-06, 9.4201e-07,
                        1.59892e-06, 6.12619e-07, 1.71268e-06, 1.51909e-06, -1.88676e-06 };
   const double fC[20] = { 2.26697e-08, 1.17164e-08, -1.01804e-08, -1.00998e-09, 8.01483e-10,
                        -3.84765e-09, 1.12943e-09, -1.31224e-09, 5.47647e-10, -8.33911e-10,
                        3.94969e-10, -7.80449e-10, 4.43006e-10, -7.08893e-10, 5.74302e-10,
                        2.0725e-11, -9.14113e-10, 1.91054e-09, -2.0859e-09, 552 };
   const double fD[20] = { -6.60835e-12, -6.60835e-12, 2.76885e-12, 5.46939e-13, -1.40372e-12,
                        1.50274e-12, -7.36886e-13, 5.61307e-13, -4.17137e-13, 3.71038e-13,
                        -3.54897e-13, 3.694e-13, -3.47638e-13, 3.87263e-13, -1.67143e-13,
                        -2.82258e-13, 8.52855e-13, -1.20665e-12, -1.20665e-12, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}


Double_t polcorr06e(Double_t x)
{
   const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00172, 1.01014, 1.01464, 1.01767,
                        1.01931, 1.02153, 1.02288, 1.02381, 1.02484,
                        1.0255, 1.02608, 1.02612, 1.02665, 1.02683,
                        1.0272, 1.02771, 1.02796, 1.02957, 1.02957 };
   const double fB[20] = { -4.36087e-07, 5.98274e-06, 6.53213e-06, 2.98058e-06, 2.00663e-06,
                        1.6744e-06, 1.7907e-06, 8.67908e-07, 9.21235e-07, 7.66664e-07,
                        5.99448e-07, 2.1107e-07, 2.41084e-07, 3.90628e-07, 1.4262e-07,
                        5.29831e-07, 1.34776e-07, 9.83413e-07, 9.67711e-07, -1.20866e-06 };
   const double fC[20] = { 7.66285e-09, 3.95494e-09, -3.45753e-09, 2.40539e-10, -1.12274e-09,
                        8.21808e-10, -7.16463e-10, -1.19022e-10, 1.67304e-10, -3.07314e-10,
                        1.5585e-10, -5.0764e-10, 5.34827e-10, -3.99432e-10, 1.74888e-10,
                        1.75847e-10, -5.33687e-10, 1.30238e-09, -1.3166e-09, 552 };
   const double fD[20] = { -2.23705e-12, -2.23705e-12, 1.11657e-12, -4.11618e-13, 5.87122e-13,
                        -4.64454e-13, 1.80305e-13, 8.64121e-14, -1.43303e-13, 1.39844e-13,
                        -2.00329e-13, 3.14755e-13, -2.81955e-13, 1.73327e-13, 2.89348e-16,
                        -2.14231e-13, 5.54368e-13, -7.90755e-13, -7.90755e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}

Double_t polcorr06eLH(Double_t x)
{
    const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 0.994516, 0.972679, 0.960898, 0.952921,
                        0.947865, 0.943409, 0.940647, 0.937503, 0.937389,
                        0.937769, 0.931257, 0.932015, 0.934042, 0.92929,
                        0.930646, 0.92995, 0.930274, 0.929284, 0.929284 };
   const double fB[20] = { -1.87097e-06, -1.63889e-05, -1.6794e-05, -7.75851e-06, -5.86274e-06,
                        -4.20462e-06, -3.16695e-06, -2.7394e-06, -1.9168e-06, 1.55691e-06,
                        -3.58877e-06, -3.8631e-06, 3.4055e-06, -2.19557e-06, -2.02513e-06,
                        1.07587e-06, -4.85539e-07, -1.43346e-07, -7.49064e-07, 9.74188e-07 };
   const double fC[20] = { -1.74581e-08, -8.81877e-09, 8.45205e-09, -2.67753e-10, 1.98494e-09,
                        -4.83016e-10, 1.42294e-09, -1.03584e-09, 1.78061e-09, 1.36587e-09,
                        -6.02682e-09, 5.77833e-09, 8.05548e-10, -5.87668e-09, 6.03099e-09,
                        -3.22211e-09, 1.80778e-09, -1.49783e-09, 9.49168e-10, 552 };
   const double fD[20] = { 5.21226e-12, 5.21226e-12, -2.63279e-12, 6.8016e-13, -7.45155e-13,
                        5.75468e-13, -7.42048e-13, 8.49991e-13, -1.25221e-13, -2.23209e-12,
                        3.56436e-12, -1.50144e-12, -2.01667e-12, 3.59368e-12, -2.79381e-12,
                        1.51869e-12, -9.98071e-13, 7.38827e-13, 7.38827e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}

Double_t polcorr06eRH(Double_t x)
{
  const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00611, 1.03034, 1.04457, 1.05404,
                        1.06106, 1.06895, 1.06952, 1.07362, 1.08018,
                        1.08193, 1.07734, 1.08117, 1.08592, 1.08248,
                        1.08569, 1.0868, 1.08801, 1.08786, 1.08786 };
   const double fB[20] = { 2.4612e-06, 1.80051e-05, 1.92259e-05, 9.56345e-06, 6.94543e-06,
                        7.47128e-06, 3.68193e-06, 7.97081e-07, 5.81759e-06, 4.8873e-06,
                        -2.80432e-06, -1.38547e-06, 6.29378e-06, -4.89177e-07, -7.7257e-07,
                        2.95753e-06, 6.82039e-07, 6.29002e-07, -3.32203e-07, 4.75329e-07 };
   const double fC[20] = { 1.85729e-08, 9.56076e-09, -8.45541e-09, -2.9682e-10, -2.07458e-09,
                        2.5509e-09, -5.98328e-09, 3.37138e-09, 1.17412e-09, -2.01677e-09,
                        -4.95028e-09, 6.23546e-09, 7.20381e-10, -6.86158e-09, 6.605e-09,
                        -3.22628e-09, 1.16514e-09, -1.21319e-09, 3.4253e-10, 552 };
   const double fD[20] = { -5.4372e-12, -5.4372e-12, 2.46334e-12, -5.36763e-13, 1.39658e-12,
                        -2.57674e-12, 2.8232e-12, -6.63124e-13, -9.63433e-13, -8.8572e-13,
                        3.37734e-12, -1.66518e-12, -2.2882e-12, 4.06416e-12, -2.96838e-12,
                        1.32591e-12, -7.18095e-13, 4.69721e-13, 4.69721e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}


Double_t polcorr0607p(Double_t x)
{
  const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00099, 1.00701, 1.0105, 1.01315,
                        1.01502, 1.01628, 1.01731, 1.01837, 1.01934,
                        1.0169, 1.02039, 1.02099, 1.02108, 1.0216,
                        1.0216, 1.02215, 1.02251, 1.02272, 1.02272 };
   const double fB[20] = { -9.56372e-07, 4.02669e-06, 4.84327e-06, 2.42702e-06, 2.13307e-06,
                        1.33717e-06, 1.02845e-06, 7.73442e-07, 1.55589e-06, -1.48855e-06,
                        3.95915e-07, 2.76553e-06, -3.34017e-07, 4.4645e-07, 1.88934e-07,
                        2.03746e-07, 5.08242e-07, 2.36639e-07, 9.07214e-08, -1.04282e-07 };
   const double fC[20] = { 5.88994e-09, 3.12917e-09, -2.38985e-09, 2.01219e-10, -4.67473e-10,
                        -2.53458e-10, -2.61759e-11, -2.04706e-10, 9.13122e-10, -3.67076e-09,
                        5.3777e-09, -3.23131e-09, 4.23751e-10, 2.82874e-10, -5.16026e-10,
                        5.29442e-10, -2.53631e-10, 7.6127e-12, -1.39784e-10, 552 };
   const double fD[20] = { -1.66562e-12, -1.66562e-12, 7.82328e-13, -2.019e-13, 6.4618e-14,
                        6.86238e-14, -5.38796e-14, 3.37356e-13, -1.38402e-12, 2.73203e-12,
                        -2.59934e-12, 1.10358e-12, -4.25161e-14, -2.41105e-13, 3.15661e-13,
                        -2.36435e-13, 7.88778e-14, -4.45039e-14, -4.45039e-14, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}


Double_t polcorr0607pLH(Double_t x)
{
 const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 1.00767, 1.04083, 1.06066, 1.07535,
                        1.08757, 1.09582, 1.10324, 1.10863, 1.11361,
                        1.11453, 1.12089, 1.12479, 1.12687, 1.1299,
                        1.13207, 1.13393, 1.13603, 1.13812, 1.13812 };
   const double fB[20] = { 1.40871e-06, 2.40037e-05, 2.65691e-05, 1.36541e-05, 1.26157e-05,
                        9.00856e-06, 6.97313e-06, 5.67371e-06, 5.13471e-06, 1.9668e-06,
                        3.02669e-06, 5.69825e-06, 2.05388e-06, 2.32407e-06, 2.53539e-06,
                        1.67469e-06, 1.72559e-06, 2.17296e-06, 9.62666e-07, -1.12769e-06 };
   const double fC[20] = { 2.68787e-08, 1.40171e-08, -1.16944e-08, -3.97166e-12, -9.36603e-10,
                        -2.33073e-09, 4.87049e-10, -1.66352e-09, 1.17552e-09, -4.045e-09,
                        5.00504e-09, -2.58515e-09, -7.15914e-10, 9.60548e-10, -7.69224e-10,
                        -1.03996e-11, 5.65041e-11, 3.48726e-10, -1.44501e-09, 552 };
   const double fD[20] = { -7.75963e-12, -7.75963e-12, 3.52972e-12, -2.81591e-13, -4.20933e-13,
                        8.5078e-13, -6.49034e-13, 8.56811e-13, -1.57624e-12, 2.7325e-12,
                        -2.29172e-12, 5.64382e-13, 5.05949e-13, -5.22038e-13, 2.29114e-13,
                        2.02004e-14, 8.82312e-14, -5.41586e-13, -5.41586e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));

}

Double_t polcorr0607pRH(Double_t x)
{
 const int fNp = 20, fKstep = 0;
   const double fDelta = -1, fXmin = 125, fXmax = 20000;
   const double fX[20] = { 125, 677.5, 1782, 2886, 3990,
                        5094, 6198, 7302.5, 8407, 9511,
                        10615, 11719, 12823, 13927.5, 15032,
                        16136, 17240, 18344, 19448, 20000 };
   const double fY[20] = { 1, 0.993065, 0.966597, 0.952058, 0.942019,
                        0.93395, 0.928726, 0.924391, 0.919624, 0.920193,
                        0.916768, 0.912849, 0.911855, 0.907812, 0.907315,
                        0.907026, 0.903474, 0.905335, 0.905915, 0.905915 };
   const double fB[20] = { -3.1909e-06, -2.00598e-05, -2.04664e-05, -9.46993e-06, -8.44074e-06,
                        -5.97418e-06, -3.78604e-06, -4.85201e-06, -1.52678e-06, -4.41344e-07,
                        -4.46979e-06, -1.63585e-06, -2.33822e-06, -2.69226e-06, 7.77848e-07,
                        -2.55408e-06, -9.98501e-07, 1.95366e-06, -1.84067e-07, 3.63692e-07 };
   const double fC[20] = { -2.02948e-08, -1.02372e-08, 9.86909e-09, 9.14427e-11, 8.40799e-10,
                        1.3934e-09, 5.88608e-10, -1.55372e-09, 4.56435e-09, -3.58116e-09,
                        -6.7793e-11, 2.63477e-09, -3.27098e-09, 2.95043e-09, 1.91358e-10,
                        -3.20941e-09, 4.61846e-09, -1.9444e-09, 8.04798e-12, 552 };
   const double fD[20] = { 6.06798e-12, 6.06798e-12, -2.95219e-12, 2.26255e-13, 1.66848e-13,
                        -2.42993e-13, -6.46545e-13, 1.84641e-12, -2.45939e-12, 1.0608e-12,
                        8.15991e-13, -1.78314e-12, 1.87759e-12, -8.32677e-13, -1.0268e-12,
                        2.36349e-12, -1.98154e-12, 5.89506e-13, 5.89506e-13, 526.196 };
   int klow=0;
   if(x<=fXmin) klow=0;
   else if(x>=fXmax) klow=fNp-1;
   else {
     if(fKstep) {
       // Equidistant knots, use histogramming
       klow = int((x-fXmin)/fDelta);
       if (klow < fNp-1) klow = fNp-1;
     } else {
       int khig=fNp-1, khalf;
       // Non equidistant knots, binary search
       while(khig-klow>1)
         if(x>fX[khalf=(klow+khig)/2]) klow=khalf;
         else khig=khalf;
     }
   }
   // Evaluate now
   double dx=x-fX[klow];
   return (fY[klow]+dx*(fB[klow]+dx*(fC[klow]+dx*fD[klow])));
}




